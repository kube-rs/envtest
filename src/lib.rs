pub mod binding {
    #![allow(warnings, errors)]
    rust2go::r2g_include_binding!();
}

/// Public API for managing a temporary Kubernetes environment.
///
/// This trait provides a bridge between Rust and Go for creating and destroying
/// temporary Kubernetes environments. Implementations of this trait are
/// generated by the `rust2go` crate on the Go side, allowing Rust code to
/// interact with Go-based test infrastructure.
#[rust2go::r2g]
trait EnvTest {
    fn create(req: Environment) -> CreateResponse;
    fn destroy(kubeconfig: String) -> DestroyResponse;
}

/// Response returned from [`EnvTest::create`].
#[derive(rust2go::R2G)]
struct CreateResponse {
    err: Option<String>,
    server: Server,
}

/// Response returned from [`EnvTest::destroy`].
#[derive(rust2go::R2G)]
struct DestroyResponse {
    err: Option<String>,
}

/// Errors that can occur while creating an environment.
#[derive(thiserror::Error, Debug)]
pub enum EnvironmentError {
    #[error("Environment create error: {0}")]
    Create(String),
}

/// Represents a request to create a test environment.
///
/// # Examples
///
/// ```rust
/// use envtest::Environment;
///
/// async fn test() -> Result<(), Box<dyn std::error::Error>> {
///     # let env = Environment::default();
///     # let server = env.create()?;
///     # let kubeconfig: serde_json::Value = server.kubeconfig()?;
///     # Ok(())
/// }
/// ```
#[derive(rust2go::R2G, Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct Environment {
    /// crd_install_options are the options for installing CRDs.
    pub crd_install_options: CRDInstallOptions,

    /// binary_assets_settings are the settings for downloading and using binary assets.
    pub binary_assets_settings: BinaryAssetsSettings,
}

#[derive(rust2go::R2G, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryAssetsSettings {
    /// download_binary_assets indicates that the envtest binaries should be downloaded.
    /// If BinaryAssetsDirectory is also set, it is used to store the downloaded binaries,
    /// otherwise a tmp directory is created.
    pub download_binary_assets: bool,

    /// download_binary_assets_version is the version of envtest binaries to download.
    /// Defaults to the latest stable version (i.e. excluding alpha / beta / RC versions).
    pub download_binary_assets_version: Option<String>,

    /// download_binary_assets_index_url is the index used to discover envtest binaries to download.
    /// Defaults to https://raw.githubusercontent.com/kubernetes-sigs/controller-tools/HEAD/envtest-releases.yaml.
    pub download_binary_assets_index_url: Option<String>,

    /// binary_assets_directory is the path where the binaries required for the envtest are
    /// located in the local environment. This field can be overridden by setting KUBEBUILDER_ASSETS.
    pub binary_assets_directory: Option<String>,
}

impl Default for BinaryAssetsSettings {
    fn default() -> Self {
        Self {
            download_binary_assets: true,
            download_binary_assets_version: Default::default(),
            download_binary_assets_index_url: Default::default(),
            binary_assets_directory: Default::default(),
        }
    }
}

/// CRDInstallOptions is a struct that represents the CRD install options
#[derive(rust2go::R2G, Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct CRDInstallOptions {
    /// Paths to directories or files containing CRDs.
    paths: Vec<String>,

    /// Specific CRD jsons to install.
    crds: Vec<String>,

    /// Whether to error if a path does not exist.
    error_if_path_missing: bool,
}

impl Environment {
    /// Create a new [`Server`] based on the current configuration.
    ///
    /// Returns an [`EnvironmentError`] if the Go side reports any errors.
    pub fn create(&self) -> Result<Server, EnvironmentError> {
        let res = EnvTestImpl::create(self.clone());
        res.err.map(EnvironmentError::Create).map_or(Ok(()), Err)?;
        Ok(res.server)
    }

    /// Add one or many CRDs to the environment.
    ///
    /// # Errors
    ///
    /// Returns an [`serde_json::Error`] if any CRDs cannot be serialized to JSON.
    pub fn with_crds(&mut self, crds: impl serde::Serialize) -> Result<&mut Self, serde_json::Error> {
        let crds = serde_json::to_value(crds)?;

        if let serde_json::Value::Array(crds) = crds {
            for crd in crds {
                self.crd_install_options
                    .crds
                    .push(serde_json::to_string(&crd)?);
            }
        } else {
            self.crd_install_options
                .crds
                .push(serde_json::to_string(&crds)?);
        }

        Ok(self)
    }
}

/// Errors that can occur while destroying an environment.
#[derive(thiserror::Error, Debug)]
pub enum DestroyError {
    #[error("Environment destroy error: {0}")]
    Destroy(String),
}

/// Represents a running test server.
#[derive(rust2go::R2G, Clone, Debug, Default, PartialEq, Eq, Hash)]
pub struct Server {
    kubeconfig: String,
}

impl Server {
    /// Deserialize the stored kubeconfig into the given type.
    ///
    /// The kubeconfig is stored as a JSON string; this helper converts it
    /// into a strongly typed value.
    ///
    /// # Errors
    ///
    /// If the kubeconfig cannot be deserialized into the given type, a
    /// [`serde_json::Error`] is returned.
    pub fn kubeconfig<T: serde::de::DeserializeOwned>(&self) -> Result<T, serde_json::Error> {
        serde_json::from_str(&self.kubeconfig)
    }

    /// Destroy the server and clean up resources.
    ///
    /// Errors returned by the Go side are converted into `DestroyError`.
    pub fn destroy(&self) -> Result<(), DestroyError> {
        let res = EnvTestImpl::destroy(self.kubeconfig.clone());
        res.err.map(DestroyError::Destroy).map_or(Ok(()), Err)
    }
}

impl Drop for Server {
    /// Automatically destroy the server when it goes out of scope.
    fn drop(&mut self) {
        let _ = self.destroy();
    }
}

#[cfg(test)]
mod tests {
    use super::Environment;

    #[test]
    fn with_crds_accepts_option() {
        let mut env = Environment::default();

        env.with_crds(Some("42")).unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["42"]);
    }

    #[test]
    fn with_crds_accepts_vec() {
        let mut env = Environment::default();

        env.with_crds(vec!["a", "b"]).unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["\"a\"", "\"b\""]);
    }

    #[test]
    fn with_crds_accepts_slice() {
        let mut env = Environment::default();
        let crds = ["1", "2", "3"];

        env.with_crds(&crds).unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["1", "2", "3"]);
    }

    #[test]
    fn with_crds_accepts_single_crd() {
        let mut env = Environment::default();

        env.with_crds("42").unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["42"]);
    }
}
