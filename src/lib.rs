pub mod binding {
    #![allow(warnings, errors)]
    rust2go::r2g_include_binding!();
}

/// Public API for managing a temporary Kubernetes environment.
///
/// This trait provides a bridge between Rust and Go for creating and destroying
/// temporary Kubernetes environments. Implementations of this trait are
/// generated by the `rust2go` crate on the Go side, allowing Rust code to
/// interact with Go-based test infrastructure.
#[rust2go::r2g]
trait EnvTest {
    fn create(req: Environment) -> CreateResponse;
    fn destroy(kubeconfig: String) -> DestroyResponse;
}

/// Response returned from [`EnvTest::create`].
#[derive(rust2go::R2G)]
struct CreateResponse {
    err: Option<String>,
    server: Server,
}

/// Response returned from [`EnvTest::destroy`].
#[derive(rust2go::R2G)]
struct DestroyResponse {
    err: Option<String>,
}

/// Errors that can occur while creating an environment.
#[derive(thiserror::Error, Debug)]
pub enum EnvironmentError {
    #[error("Environment create error: {0}")]
    Create(String),
    #[error("CRD serialization error: {0}")]
    CrdSerialize(#[from] serde_json::Error),
    #[error("Unsupported CRD type. Expected string, object, or array of those.")]
    UnsupportedCrdType,
}

/// Represents a request to create a test environment.
///
/// # Examples
///
/// ```rust
/// async fn test() -> Result<(), Box<dyn std::error::Error>> {
///     let env = envtest::Environment::default();
///     let server = env.create()?;
///     let kubeconfig = server.kubeconfig()?;
///     panic!("environment created");
///     Ok(())
/// }
/// ```
#[derive(rust2go::R2G, Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct Environment {
    /// crd_install_options are the options for installing CRDs.
    pub crd_install_options: CRDInstallOptions,

    /// binary_assets_settings are the settings for downloading and using binary assets.
    pub binary_assets_settings: BinaryAssetsSettings,
}

#[derive(rust2go::R2G, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryAssetsSettings {
    /// download_binary_assets indicates that the envtest binaries should be downloaded.
    /// If BinaryAssetsDirectory is also set, it is used to store the downloaded binaries,
    /// otherwise a tmp directory is created.
    pub download_binary_assets: bool,

    /// download_binary_assets_version is the version of envtest binaries to download.
    /// Defaults to the latest stable version (i.e. excluding alpha / beta / RC versions).
    pub download_binary_assets_version: Option<String>,

    /// download_binary_assets_index_url is the index used to discover envtest binaries to download.
    /// Defaults to https://raw.githubusercontent.com/kubernetes-sigs/controller-tools/HEAD/envtest-releases.yaml.
    pub download_binary_assets_index_url: Option<String>,

    /// binary_assets_directory is the path where the binaries required for the envtest are
    /// located in the local environment. This field can be overridden by setting KUBEBUILDER_ASSETS.
    pub binary_assets_directory: Option<String>,
}

impl Default for BinaryAssetsSettings {
    fn default() -> Self {
        Self {
            download_binary_assets: true,
            download_binary_assets_version: Default::default(),
            download_binary_assets_index_url: Default::default(),
            binary_assets_directory: Default::default(),
        }
    }
}

/// CRDInstallOptions is a struct that represents the CRD install options
#[derive(rust2go::R2G, Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct CRDInstallOptions {
    /// Paths to directories or files containing CRDs.
    paths: Vec<String>,

    /// Specific CRD jsons to install.
    crds: Vec<String>,

    /// Whether to error if a path does not exist.
    error_if_path_missing: bool,
}

impl Environment {
    /// Create a new [`Server`] based on the current configuration.
    ///
    /// Returns an [`EnvironmentError`] if the Go side reports any errors.
    pub fn create(&self) -> Result<Server, EnvironmentError> {
        let res = EnvTestImpl::create(self.clone());
        res.err.map(EnvironmentError::Create).map_or(Ok(()), Err)?;
        Ok(res.server)
    }

    /// Add one or many CRDs to the environment.
    ///
    /// # Errors
    ///
    /// Returns an [`EnvironmentError`] when serialization fails or an unsupported
    /// CRD value is provided.
    pub fn with_crds(mut self, crds: impl serde::Serialize) -> Result<Self, EnvironmentError> {
        match serde_json::to_value(crds)? {
            serde_json::Value::Array(crds) => {
                self.crd_install_options.crds.reserve(crds.len());
                for crd in crds {
                    self.crd_install_options
                        .crds
                        .push(serde_json::to_string(&crd)?);
                }
            }
            serde_json::Value::Object(crd) => {
                self.crd_install_options
                    .crds
                    .push(serde_json::to_string(&crd)?);
            }
            serde_json::Value::String(crd) => {
                self.crd_install_options
                    .crds
                    .push(serde_json::Value::String(crd).to_string());
            }
            _ => return Err(EnvironmentError::UnsupportedCrdType),
        }

        Ok(self)
    }
}

/// Errors that can occur while destroying an environment.
#[derive(thiserror::Error, Debug)]
pub enum ServerError {
    #[error("Environment destroy error: {0}")]
    Destroy(String),
}

#[cfg(feature = "kube")]
#[derive(thiserror::Error, Debug)]
pub enum ClientError {
    #[error("Deserialize kubeconfig error: {0}")]
    Kubeconfig(#[from] serde_json::Error),

    #[error("Creating client error: {0}")]
    Client(#[from] kube::Error),
}

/// Represents a running test server.
#[derive(rust2go::R2G, Clone, Debug, Default, PartialEq, Eq, Hash)]
pub struct Server {
    kubeconfig: String,
}

impl Server {
    /// Destroy the server and clean up resources.
    ///
    /// Errors returned by the Go side are converted into [`ServerError`].
    pub fn destroy(&self) -> Result<(), ServerError> {
        let res = EnvTestImpl::destroy(self.kubeconfig.clone());
        res.err.map(ServerError::Destroy).map_or(Ok(()), Err)
    }

    /// Build a typed client from the stored kubeconfig.
    ///
    /// This first deserializes the kubeconfig using [`Self::kubeconfig`] and
    /// then converts it into `C` via `TryFrom`.
    ///
    /// ```rust
    /// # tokio_test::block_on(async {
    /// async fn run() -> Result<(), Box<dyn std::error::Error>> {
    ///     let server = envtest::Environment::default().create()?;
    ///     let client = server.client()?;
    ///     server.destroy()?;
    ///     Ok(())
    /// }
    /// run().await.unwrap()
    /// # })
    /// ```
    ///
    /// # Errors
    ///
    /// Returns [`ClientError::Kubeconfig`] if [`kube::config::Kubeconfig`] deserialization fails,
    /// or [`ClientError::Client`] if conversion into [`kube::Client`] fails.
    #[cfg(feature = "kube")]
    #[inline]
    pub fn client(&self) -> Result<kube::Client, ClientError> {
        Ok(self.kubeconfig()?.try_into()?)
    }

    /// Deserialize the stored kubeconfig into the given type.
    ///
    /// ```rust
    /// let server = envtest::Environment::default().create()?;
    /// let cfg = server.kubeconfig()?;
    /// server.destroy()?;
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    ///
    /// # Errors
    ///
    /// If the kubeconfig cannot be deserialized into the given type, a
    /// [`serde_json::Error`] is returned.
    #[cfg(feature = "kube")]
    #[inline]
    pub fn kubeconfig(&self) -> Result<kube::config::Kubeconfig, serde_json::Error> {
        serde_json::from_str(self.as_ref())
    }
}

impl AsRef<str> for Server {
    fn as_ref(&self) -> &str {
        &self.kubeconfig
    }
}

impl Drop for Server {
    /// Automatically destroy the server when it goes out of scope.
    fn drop(&mut self) {
        let _ = self.destroy();
    }
}

#[cfg(test)]
mod tests {
    use super::{Environment, EnvironmentError};

    #[tokio::test]
    async fn e2e() {
        let env = Environment::default();
        let server = env.create().unwrap();
        server.destroy().unwrap()
    }

    #[test]
    fn with_crds_accepts_option() {
        let env = Environment::default().with_crds(Some("42")).unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["\"42\""]);
        let err = env.create().unwrap_err();
        assert!(matches!(err, EnvironmentError::Create(_)));
        assert!(
            err.to_string()
                .contains("json: cannot unmarshal string into Go value")
        );
    }

    #[cfg(feature = "kube")]
    #[tokio::test]
    async fn with_crds_accepts_simple_real_crd() {
        let crd = serde_json::json!({
            "apiVersion": "apiextensions.k8s.io/v1",
            "kind": "CustomResourceDefinition",
            "metadata": { "name": "widgets.example.com" },
            "spec": {
                "group": "example.com",
                "scope": "Namespaced",
                "names": {
                    "plural": "widgets",
                    "singular": "widget",
                    "kind": "Widget"
                },
                "versions": [{
                    "name": "v1",
                    "served": true,
                    "storage": true,
                    "schema": {
                        "openAPIV3Schema": {
                            "type": "object"
                        }
                    }
                }]
            }
        });

        let env = Environment::default().with_crds(crd.clone()).unwrap();
        assert_eq!(env.crd_install_options.crds, vec![crd.to_string()]);
        let server = env.create().unwrap();
        let client = server.client().unwrap();
        let groups = client.list_api_groups().await.unwrap();
        groups.groups.iter().find(|g| g.name == "example.com").ok_or(()).unwrap();
    }

    #[test]
    fn with_crds_accepts_vec() {
        let env = Environment::default().with_crds(vec!["a", "b"]).unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["\"a\"", "\"b\""]);
        let err = env.create().unwrap_err();
        assert!(matches!(err, EnvironmentError::Create(_)));
        assert!(
            err.to_string()
                .contains("json: cannot unmarshal string into Go value")
        );
    }

    #[test]
    fn with_crds_accepts_slice() {
        let mut env = Environment::default();
        let crds = ["1", "2", "3"];

        env = env.with_crds(&crds).unwrap();

        assert_eq!(
            env.crd_install_options.crds,
            vec!["\"1\"", "\"2\"", "\"3\""]
        );
        let err = env.create().unwrap_err();
        assert!(matches!(err, EnvironmentError::Create(_)));
        assert!(
            err.to_string()
                .contains("json: cannot unmarshal string into Go value")
        );
    }

    #[test]
    fn with_crds_accepts_single_crd() {
        let mut env = Environment::default();

        env = env.with_crds("42").unwrap();

        assert_eq!(env.crd_install_options.crds, vec!["\"42\""]);
        let err = env.create().unwrap_err();
        assert!(matches!(err, EnvironmentError::Create(_)));
        assert!(
            err.to_string()
                .contains("json: cannot unmarshal string into Go value")
        );
    }
}
